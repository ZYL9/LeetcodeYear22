# 好子集的数目

给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。

比方说，如果 nums = [1, 2, 3, 4] ：
[2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。
[1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。
请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。

nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。



示例 1：

输入：nums = [1,2,3,4]
输出：6
解释：好子集为：
- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
示例 2：

输入：nums = [4,2,3,15]
输出：5
解释：好子集为：
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。


# Review

穷举
突破口在数据范围30，30以内的数就可以列出来了，详细可看代码最后的表，带有完全平方的不能用； 所以首先统计每个数字出现的次数，再看哪几个可以相互组合； 对于1，1可以随意重复出现，统计完其他后最后考虑，答案乘2的（1出现次数）次幂；

对于17，19，23，29，他们和任何人都互斥，可以任意放，计算完其他后可以更新为 ans = ans + ((ans + 1) * cnt[num]) 原有答案+搭配该数+只选该数；

对于其他的2,3,5,6,7,10,11,13,14,15,21,22,26,30； 从中不重复的选任意个，然后判断合法性（该数出现过且选择的数们互质），累加这样组合下来的答案； 每一种选择方案的个数为tmpcnt *= cnt[ch];

而从这14个数不重复选取的方案数，可以想到状态压缩，枚举1到 1 << 14 这么多状态即可，2^14 = 16384,小问题；



动态规划

找到质数然后再划分子集
包含平方的直接舍掉 f[i][mask]=f[i−1][mask]
不含平方的 f[i][mask]=f[i−1][mask]+f[i−1][mask\subset]×freq[i]

freq[i] 表示数组 nums 中 i 出现的次数；

mask\subset 表示从二进制表示mask中去除所有在subset 中出现的1，可以使用按位异或运算实现。这里需要保证subset是mask 的子集，可以使用按位与运算来判断。

思想和穷举其实类似
